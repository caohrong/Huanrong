<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="类的基本思想是数据抽象和分装、数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数整体以及定义类所需的各种私有函数。">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="类">
<meta property="og:url" content="http://caohr.com/2018/12/21/C++/类/index.html">
<meta property="og:site_name" content="Huanrong">
<meta property="og:description" content="类的基本思想是数据抽象和分装、数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数整体以及定义类所需的各种私有函数。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-12-21T07:45:30.873Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="类">
<meta name="twitter:description" content="类的基本思想是数据抽象和分装、数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数整体以及定义类所需的各种私有函数。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://caohr.com/2018/12/21/C++/类/"/>





  <title>类 | Huanrong</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-61905451-1', 'auto');
  ga('send', 'pageview');
</script>











</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Huanrong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">iOSDev</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://caohr.com/2018/12/21/C++/类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huanrong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huanrong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">类</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-21T15:41:13+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/21/C++/类/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/12/21/C++/类/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>类的基本思想是<code>数据抽象</code>和<code>分装</code>、数据抽象是一种依赖于<code>接口</code>和<code>实现</code>分离的编程技术。类的接口包括所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数整体以及定义类所需的各种私有函数。</p>
<a id="more"></a>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="设计Sales-data类"><a href="#设计Sales-data类" class="headerlink" title="设计Sales_data类"></a>设计Sales_data类</h3><h4 id="使用改进的Sales-data类"><a href="#使用改进的Sales-data类" class="headerlink" title="使用改进的Sales_data类"></a>使用改进的Sales_data类</h4><h3 id="定义改进的Sales-data类"><a href="#定义改进的Sales-data类" class="headerlink" title="定义改进的Sales_data类"></a>定义改进的Sales_data类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line">    <span class="comment">//新成员： 关于Sales_data对象的操作</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//数据成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;, Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="定义成员函数"><a href="#定义成员函数" class="headerlink" title="定义成员函数"></a>定义成员函数</h4><p>尽管所有的成员都必须在类的内部声明，但是成员函数可以定义在类的内也可以定义在类外。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo;&#125;</span><br></pre></td></tr></table></figure>
<p>关于<code>isbn</code>函数，那么他是如何获得<code>bookNo</code>成员所依赖的对象的？</p>
<h4 id="引入this"><a href="#引入this" class="headerlink" title="引入this"></a>引入this</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total.isbn()</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用了点运算符，来访问total对象的isbn成员，然后再调用它。<br>当我们调用成员函数时，实际上是在替某个对象调用它。如果<code>isbn</code>指向<code>Sales_data</code>的成员（例如bookNo），则它隐式的指向调用该函数的对象的成员。在上面所示的调用中，当<code>isbn</code>返回<code>bookNo</code>时，实际上是隐式地返回<code>total.bookNo</code>。<br>成员函数通过一个名为<code>this</code>的额外的隐式参数来访问调用它的对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化<code>this</code>。例如，如果调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total.sibn()</span><br></pre></td></tr></table></figure>
<p>则编译器负责把total的地址传递给<code>isbn</code>的隐式形参<code>this</code>，可以等价于为编译器将该调用重写成了如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::isbn(&amp;total)</span><br></pre></td></tr></table></figure>
<p>任何对类成员的直接访问都被看作是<code>this</code>的隐式引用，也就是说，当isbn使用bookNo时，它隐私地使用this指向的成员，就像我们书写了<code>this-&gt;bookNo</code>一样。</p>
<h4 id="引入const成员函数❓❓❓"><a href="#引入const成员函数❓❓❓" class="headerlink" title="引入const成员函数❓❓❓"></a>引入const成员函数❓❓❓</h4><p><code>this</code>如果是常量</p>
<p><code>isbn</code>函数的另一个关键之处是紧随参数列表之后的<code>const</code>关键字，这里，const的作用是修改隐式this指针的类型。<br>默认情况下，<code>this的类型</code>是指向类型非常量版本的常量指针。例如在<code>this</code>的类型是<code>Sales_data *const</code>。意味着不能将<code>this</code>绑定到一个常量对象上。这一情况也就使我们不能在一个常量对象上调用普通的成员函数。</p>
<p>如果<code>isbn</code>是一个普通函数而且<code>this</code>是一个普通的指针参数，则我们应该把this申明成<code>const Sales_data *const</code>。在<code>isbn</code>的函数体内不会改变<code>this</code>所指的对象，所以把<code>this</code>设置为指向常量的指针有助于提高函数的灵活性。</p>
<blockquote>
<p>因为<code>this</code>是隐式的不会出现在列表参数中，所以C++的做法是允许把<code>const</code>关键字放在成员函数的参数列表之后，此时、紧跟在参数列表后面的<code>const</code>表示<code>this</code>是一个指向常量的指针。像这样使用<code>const</code>的成员函数被称为<strong>常量成员函数</strong>。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Sales_data::isbn(<span class="keyword">const</span> Sales_data *<span class="keyword">const</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;isbn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>this</code>是常量的指针，所以常量成员函数不能修改调用它的对象的内容。在上例中，<code>isbn</code>可以读取调用它的对象的数据成员，但不能写入新值。</p>
<p>常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p>
<h4 id="类作用域和成员函数"><a href="#类作用域和成员函数" class="headerlink" title="类作用域和成员函数"></a>类作用域和成员函数</h4><p>类本身就是一个作用域。因为编译器编译器，首先编译成员的声明，然后才轮到成员函数。因此，成员函数体可以随意使用类中的其他成员而无需在意这些成员出现的次序。</p>
<h4 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h4><p>在类的外部定义成员函数，成员函数的定义必须和它的申明匹配。也就是说，返回类型、参数列表和函数名都都得与类内部的申明保持一致。如果成员被声明称常量成员函数，那么它的定义也必须在参数列表后明确指定<code>const</code>属性。而且类外定义的成员的名字也必须包含它所属的类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Sales_data::avg_price() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (units_sold) &#123;</span><br><span class="line">        <span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h4><p>函数<code>combine</code>的设计初衷类似于符合运算符+=，调用该函数的对象代表的是赋值运算符左侧的运算对象，右侧运算对象则通过显式的实参传入函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data&amp; Sales_data::combine(<span class="keyword">const</span> Sales_data &amp;rhs) &#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">total.combine(trans);  更新变量total当前的值</span><br></pre></td></tr></table></figure>
<p>total的地址绑定到隐式的this参数上，而rhs绑定到了trans上。</p>
<p>【❓❓❓】该函数一个值关注的部分是它的返回类型和返回语句。一般来说，但给我们定义的函数类型于某个内置运算符，应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左侧运运算对象当成左值返回，因此为了与它保持一致，<code>combine</code>函数必须返回引用类型。因此此时的左侧运算对象是一个<code>Sales_data</code>的对象，所以返回类型应该是<code>Sales_data&amp;</code>。</p>
<h3 id="定义类相关的成员函数"><a href="#定义类相关的成员函数" class="headerlink" title="定义类相关的成员函数"></a>定义类相关的成员函数</h3><p>我们定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开来。如果函数在概念上属于类但不定义在类中，则它一般应与类声明（而非定义）在同一个头文件中。这种方式下，用户使用接口的任何部分都只需要引入一个文件。</p>
<h4 id="定义read和print函数"><a href="#定义read和print函数" class="headerlink" title="定义read和print函数"></a>定义read和print函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;is, Sales_data &amp;item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os, Sales_data &amp;item)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">" "</span> &lt;&lt; item.revenue &lt;&lt; <span class="string">""</span> &lt;&lt; item.avg_price();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>read</code>函数从给定流中将数据读取到给定的对象中，print函数则负责将给定对象的内容打印到给定的流中。</p>
<p><code>read</code>和<code>print</code>分别接受一个各自<code>IO</code>类型的引用作为其参数，这是因为<code>IO</code>类属于不能拷贝的类型，英雌我们只能通过引用来传递它们。而且，因为读取和写入的操作会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。</p>
<h4 id="定义add函数"><a href="#定义add函数" class="headerlink" title="定义add函数"></a>定义add函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span> </span>&#123;</span><br><span class="line">    Sales_data sum = lhs;   <span class="comment">//把lhs的数据成员拷贝给sum</span></span><br><span class="line">    sum.combine(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，拷贝类的对象其实拷贝的是对象的数据成员。在拷贝工作完成之后，sum里面的参数与被拷贝的一致。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>每个类都分别定义了它的对象被初始化的方式, 类通过一个或几个特殊的成员函数来控制对象的初始过程，这些函数叫做<code>构造函数</code>。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会指向构造函数。</p>
<ul>
<li>构造函数的名字和类的名字相同。和其他函数不一样的是，构造函数没有返回值。除此之外类似于其他的函数，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。类可以包含多个构造器，和其他重载函数差不多不同的构造函数之前必须在参数数量或参数类型上有所区别。</li>
<li>构造函数不能声明称<code>const</code>的。当我们创建类的一个<code>const</code>对象时，知道构造器函数完成初始化过程，对象才能真正取得其<code>常量</code>属性，因此，构造函数在<code>const</code>对象的构造过程中可以向其写值。</li>
</ul>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>类通过一个特俗的构造函数来控制默认初始化过程，这个函数叫做默认构造函数。默认构造函数无需任何实参。编译器创建的默认构造函数又被称为<strong>合成的默认构造函数</strong>。</p>
<p>如果存在类内的初始值，则直接用他来初始化成员。否则，默认初始化该成员。</p>
<h4 id="某些类不能依赖于合成的默认构造函数"><a href="#某些类不能依赖于合成的默认构造函数" class="headerlink" title="某些类不能依赖于合成的默认构造函数"></a>某些类不能依赖于合成的默认构造函数</h4><p>对于一个普通的类来说，必须定义它自己的默认构造函数，原因：</p>
<ol>
<li>编译器只有在类不包含任何构造器的情况下才会替我们生成默认的构造函数。</li>
<li>含有内置类型或符合类型成员的类应该在类的内部初始化这些成员，否则用户就会得到未定义的值。</li>
<li>有的时候编译器不能为某些类合成默认的构造器。如果类中包含了一个其他类类型的成员且这个成员的类型没有默认的构造函数。</li>
</ol>
<h4 id="定义Sales-data的构造函数"><a href="#定义Sales-data的构造函数" class="headerlink" title="定义Sales_data的构造函数"></a>定义Sales_data的构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s) : bookNo(s) &#123;&#125;</span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p) : bookNo(s), units_sodl(n), revenue(p*n) &#123;&#125;</span><br><span class="line">Sales_data(<span class="built_in">std</span>::istream &amp;);</span><br></pre></td></tr></table></figure>
<h4 id="default的含义"><a href="#default的含义" class="headerlink" title="=default的含义"></a>=default的含义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>因为该构造函数不接受任何实参，所以它是一个默认的构造函数。定义这个主要是我们即想要默认的构造函数，也想要其他的构造函数。</p>
<p>如果我们需要默认的行为，那么我们通过在参数列表后面写上<code>= default</code>来要求编译器生成构造函数。构造函数也可以声明在类的内部也可以和其他函数一样声明在类的外部。和其他函数一样，如果= default在类的内部，则默认构造器是内联的；如果它在类的外部，则该成员默认情况下不是内联的。</p>
<h4 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s) : bookNo(s) &#123;&#125;</span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p) : bookNo(s), units_sodl(n), revenue(p*n) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>新出现的部分称为<strong>构造函数初始值列表</strong>，它负责为新创建的对象的一个或几个数据成员赋初值。</p>
<h4 id="在类的外部定义构造函数"><a href="#在类的外部定义构造函数" class="headerlink" title="在类的外部定义构造函数"></a>在类的外部定义构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❓❓❓</span><br></pre></td></tr></table></figure>
<p>当我们的类的外部定义构造函数时，必须指明该构造函数是那个类的成员。<br>因为该函数和的名字和类的名字相同，所以它是一个构造函数。</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><p>除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。<br>对象在几种情况下会被拷贝，</p>
<ul>
<li>如我们初始化变量以及以值的方式传递或返回一个对象等。</li>
<li>当我们使用了赋值运算符</li>
<li>当对象不再存在时执行销毁的操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">total = trans;   <span class="comment">//处理下一本的信息</span></span><br><span class="line"><span class="comment">// Sales_data 的默认赋值操作等价于+</span></span><br><span class="line">total.bookNo = trans.bookNo;</span><br><span class="line">total.units_sold = trans.units_sold;</span><br><span class="line">total.revenue = trans.revenue;</span><br></pre></td></tr></table></figure>
<h4 id="某些类不能依赖于合成的版本"><a href="#某些类不能依赖于合成的版本" class="headerlink" title="某些类不能依赖于合成的版本"></a>某些类不能依赖于合成的版本</h4><p>很多动态内存的类能（而且应该）使用vector对象或者stringdui’x</p>
<h2 id="访问控与封装"><a href="#访问控与封装" class="headerlink" title="访问控与封装"></a>访问控与封装</h2><p>我们使用说明符加强肋的分装性。</p>
<ul>
<li>定义在<code>public</code>说明符之后的成员在整个程序内可被访问，public成员定义类的接口。</li>
<li>定义在<code>private</code>说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分分装了类的实现细节。</li>
</ul>
<p>一个类可以包含0个或者多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格的规定。</p>
<h4 id="使用class或struct关键字"><a href="#使用class或struct关键字" class="headerlink" title="使用class或struct关键字"></a>使用class或struct关键字</h4><p><code>class</code>和<code>struct</code>唯一的区别是，<code>struct</code>和<code>class</code>默认访问权限不太一样。</p>
<p>如果我们使用<code>struct</code>关键字，则定义在第一个访问说明符之前的成员是<code>public</code>的；相反，如果我们使用<code>class</code>关键字，则这些成员是<code>private</code>的。</p>
<blockquote>
<p>这个在<code>swift</code>中和<code>Objective-C</code>中的区别都很大。</p>
</blockquote>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span> <span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>友元声明只能出现在类的内部，但是类内出现的具体位置不限。友元不是类的成员也不收它所在区域访问控制级别的约束。一般最好集中定义在开头或者结尾。</p>
<h4 id="友元的声明"><a href="#友元的声明" class="headerlink" title="友元的声明"></a>友元的声明</h4><p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。我们希望类的用户能够调用某个友元的函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。</p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><p>类型成员、类的成员的类内初始值、可变数据成员，内联成员函数、从成员函数返回<code>*this</code>, 关于如何定义并使用类类型以及友元类的更多知识。</p>
<h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><h4 id="定义一个类型成员"><a href="#定义一个类型成员" class="headerlink" title="定义一个类型成员"></a>定义一个类型成员</h4><h4 id="Screen类的成员函数"><a href="#Screen类的成员函数" class="headerlink" title="Screen类的成员函数"></a>Screen类的成员函数</h4><h4 id="令成员作为内联函数"><a href="#令成员作为内联函数" class="headerlink" title="令成员作为内联函数"></a>令成员作为内联函数</h4><p>定义在类内部的成员函数是自动<code>inline</code>的。因此，Screen的构造函数和返回光标所指字符的<code>get</code>函数默认是<code>inline</code>函数。</p>
<p>这部分的意思就是你可以在函数声明的地方声明inline，也可以在实现的部分声明inline，亦或两个地方都声明 也是合法的</p>
<h4 id="重载成员函数"><a href="#重载成员函数" class="headerlink" title="重载成员函数"></a>重载成员函数</h4><p>成员函数也可以重载，成员函数函数匹配过程同样与非成员函数非常类似。</p>
<h4 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h4><p>有时(但是并不频繁)会发生一种情况，我们希望能修改类的某个数据成员，【即使是在一个<code>const</code>成员函数内。可以通过变量的声明中加入<code>mutable</code>关键字做到这一点。】</p>
<p>【一个可变数据成员永远不会是<code>const</code>，即使它是<code>const</code>对象的成员。因此，一个const成员函数可以改变一个可变成员的值。】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> access_ctr;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">char</span> Screen::get(pos r, pos c) <span class="keyword">const</span> &#123;</span><br><span class="line">    ++ access_ctr;</span><br><span class="line">    pos row = r * width;</span><br><span class="line">    <span class="keyword">return</span> contents[row + c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管some_member是一个<code>const</code>成员函数，它仍然能够改变<code>access_ctr</code>的值。该成员是个可变成员，因此任何成员函数，包括<code>const</code>函数在内部都能改变它的值。</p>
<p>【问题】还是不太明白为什么声明称<code>const</code>的函数就不能修改，虽然我知道这个<code>const</code>是修饰隐式的<code>this</code>的。❓❓❓。</p>
<h4 id="类数据成员的初始值"><a href="#类数据成员的初始值" class="headerlink" title="类数据成员的初始值"></a>类数据成员的初始值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt; screens&#123;Screen(<span class="number">24</span>, <span class="number">80</span>, <span class="string">' '</span>)&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们使用一个单独元素值对<code>vector</code>成员执行了列表初始化，这个Screen的值被传递给<code>Vector&lt;Screen&gt;</code>的构造函数，从而创建一个单元素的vector对象。</p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen &amp;<span class="title">set</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line">    <span class="function">Screen &amp;<span class="title">set</span><span class="params">(pos, pos, <span class="keyword">char</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Screen &amp;Screen::<span class="built_in">set</span>(<span class="keyword">char</span> c) &#123;</span><br><span class="line">    contents[cursor] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Screen &amp;Screen::<span class="built_in">set</span>(pos r, pos col, <span class="keyword">char</span> ch) &#123;</span><br><span class="line">    contents[r*width + col] = ch;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回引用的函数是左值的，意味着这些函数返回的是对象本省而非对象的副本。<code>myScrren.move(4, 0).set(&#39;#&#39;);</code></p>
<p>如果令<code>move</code>和<code>set</code>返回<code>Screen</code>而非<code>Screen&amp;</code>，则上诉语句将要改为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果move返回Screen而非Screen&amp;</span></span><br><span class="line">Screen temp = myScreen.move(<span class="number">4.0</span>);</span><br><span class="line">temp.<span class="built_in">set</span>(<span class="string">'#'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="从const成员函数返回-this-❓"><a href="#从const成员函数返回-this-❓" class="headerlink" title="从const成员函数返回*this ❓"></a>从const成员函数返回*this ❓</h4><h4 id="基于const的重载-❓"><a href="#基于const的重载-❓" class="headerlink" title="基于const的重载 ❓"></a>基于const的重载 ❓</h4><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">First</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> memi;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Second</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> memi;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMem</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使两个类的成员列表完全一致，他们也是不同的类型。我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我么也可以把类名关键字class或struct后面:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data item1;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> <span class="title">item1</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里把<code>class</code>和<code>struct</code>都称为了类，这点和<code>Swift</code>不同。</p>
</blockquote>
<h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>;</span></span><br></pre></td></tr></table></figure>
<p>C++也允许在类还没有定义的时候使用类，但是只是可以指向这种类型的指针或者引用，也可以声明(但是不能定义)以不完全类型作为参数或者返回类型的函数。总之不能涉及到类内部信息的操作，例如访问成员变量或者函数、或者初始化。因为这个时候你还不知道类的具体细节。这些和<code>Objective-C</code>类似。</p>
<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类还可以把其他的类定义为友元，也可以把其他类的成员函数定义为友元。友元函数能定义在类的内部，这样的函数是隐身内联的。</p>
<h4 id="类之间的友元关系"><a href="#类之间的友元关系" class="headerlink" title="类之间的友元关系"></a>类之间的友元关系</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将Window_mgr声明成Screen的友元以后，<code>window_mgr</code>可以使用<code>Screen</code>的私有变量和成员函数。<br>友元不具有传递性，每个类负责控制自己的友元类或友元函数。</p>
<h4 id="令成员函数作为友元"><a href="#令成员函数作为友元" class="headerlink" title="令成员函数作为友元"></a>令成员函数作为友元</h4><p>把一个成员函数声明称友元时，我们必须明确指出该函数属于哪个类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Window_mgr::clear(ScreenIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想令某个成员函数作为友元，我们必须仔细组织程序结构以满足声明和定义的彼此依赖关系。</p>
<ul>
<li>首先声明要被申请为友元的函数的声明，不要实现。</li>
<li>定义函数，并写入友元函数的声明。</li>
<li>实现友元函数</li>
</ul>
<h4 id="函数重载和友元"><a href="#函数重载和友元" class="headerlink" title="函数重载和友元"></a>函数重载和友元</h4><p>如果一个类想把一组重载函数声明成为它的友元，它需要对这组函数中的每一个分别声明。</p>
<h4 id="友元声明和作用域"><a href="#友元声明和作用域" class="headerlink" title="友元声明和作用域"></a>友元声明和作用域</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function">firend <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* 友元函数可以定义在类的内部 */</span>&#125;</span><br><span class="line">    x() &#123; f(); &#125;     <span class="comment">// 错误：f还没有被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> X::g() &#123; <span class="keyword">return</span> f(); &#125;   <span class="comment">//错误：f还没有被声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;     <span class="comment">//声明</span></span><br><span class="line"><span class="keyword">void</span> X::h() &#123; <span class="keyword">return</span> f(); &#125;  <span class="comment">//正确：现在f的声明在作用域中了。</span></span><br></pre></td></tr></table></figure>
<p>这里要说明的是友元的声明并不是函数的声明。</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符访问。不论哪种情况，跟在运算符之后的名字都必须是对应的成员。</p>
<h4 id="作用域和定义在类外部的成员"><a href="#作用域和定义在类外部的成员" class="headerlink" title="作用域和定义在类外部的成员"></a>作用域和定义在类外部的成员</h4><p>一个类就是一个作用域的事实能够很好的解释为什么当我们在类的外部定义成员函数时必须同时提供类名和函数名。</p>
<p>需要注意的是，当我们在类外面写函数的实现的时候，因为返回值是类名之前也就是在作用域之外，如果返回的值是作用域中的，那么他还是要在前面加上作用域也就是类名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="keyword">const</span> Screen&amp;)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Window_mgr::ScreenIndex Window_mgr::addScreen(<span class="keyword">const</span> Screen &amp;s) &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="名字查找和类的作用域"><a href="#名字查找和类的作用域" class="headerlink" title="名字查找和类的作用域"></a>名字查找和类的作用域</h3><p>名字查找</p>
<ul>
<li>首先，在名字所在块中寻找其声明语法，只考虑在名字的使用之前出现的声明。</li>
<li>如果没有找到，继续查找外层作用域。</li>
<li>如果最终没有找到匹配的声明，则程序报错。<br>对于内部的成员函数</li>
<li>首先、编译成员的声明。</li>
<li>知道类全部可见后才编译函数体。</li>
</ul>
<p>编译器处理完类中的全部声明后才会处理成员函数的意义。</p>
<h4 id="用于类成员声明的名字查找"><a href="#用于类成员声明的名字查找" class="headerlink" title="用于类成员声明的名字查找"></a>用于类成员声明的名字查找</h4><h4 id="类型名要特殊处理"><a href="#类型名要特殊处理" class="headerlink" title="类型名要特殊处理"></a>类型名要特殊处理</h4><h4 id="成员定义中普通块作用域的名字查找"><a href="#成员定义中普通块作用域的名字查找" class="headerlink" title="成员定义中普通块作用域的名字查找"></a>成员定义中普通块作用域的名字查找</h4><h4 id="类作用域之外，在外围的作用域中查找"><a href="#类作用域之外，在外围的作用域中查找" class="headerlink" title="类作用域之外，在外围的作用域中查找"></a>类作用域之外，在外围的作用域中查找</h4><h4 id="在文件中名字的出现处对其进行解析"><a href="#在文件中名字的出现处对其进行解析" class="headerlink" title="在文件中名字的出现处对其进行解析"></a>在文件中名字的出现处对其进行解析</h4><h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表-1"><a href="#构造函数初始值列表-1" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><h4 id="构造函数的初始值有时必不可少"><a href="#构造函数的初始值有时必不可少" class="headerlink" title="构造函数的初始值有时必不可少"></a>构造函数的初始值有时必不可少</h4><h4 id="成员初始化的顺序"><a href="#成员初始化的顺序" class="headerlink" title="成员初始化的顺序"></a>成员初始化的顺序</h4><h4 id="默认实参和构造函数"><a href="#默认实参和构造函数" class="headerlink" title="默认实参和构造函数"></a>默认实参和构造函数</h4><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><h3 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h3><h4 id="使用默认构造函数"><a href="#使用默认构造函数" class="headerlink" title="使用默认构造函数"></a>使用默认构造函数</h4><h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><h4 id="只允许一部类类型转换"><a href="#只允许一部类类型转换" class="headerlink" title="只允许一部类类型转换"></a>只允许一部类类型转换</h4><h4 id="类类型转换不是总是有效"><a href="#类类型转换不是总是有效" class="headerlink" title="类类型转换不是总是有效"></a>类类型转换不是总是有效</h4><h4 id="抑制构造函数定义的隐式转换"><a href="#抑制构造函数定义的隐式转换" class="headerlink" title="抑制构造函数定义的隐式转换"></a>抑制构造函数定义的隐式转换</h4><h4 id="explicit构造函数只能用于直接初始化"><a href="#explicit构造函数只能用于直接初始化" class="headerlink" title="explicit构造函数只能用于直接初始化"></a>explicit构造函数只能用于直接初始化</h4><h4 id="为转换显式地使用构造函数"><a href="#为转换显式地使用构造函数" class="headerlink" title="为转换显式地使用构造函数"></a>为转换显式地使用构造函数</h4><h4 id="标准库中含有显式构造函数的类"><a href="#标准库中含有显式构造函数的类" class="headerlink" title="标准库中含有显式构造函数的类"></a>标准库中含有显式构造函数的类</h4><h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p><strong>聚合类</strong>使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足一下条件，我们可以说它是聚合的：</p>
<ul>
<li>所有的成员都是public的。</li>
<li>没有定义任何的构造函数。</li>
<li>没有任何的初始值。</li>
<li>没有基类，也没有<code>virtual</code>函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>聚合类的初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data vall = &#123;<span class="number">0</span>, <span class="string">"Anan"</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始值的顺序必须与声明的一致。</li>
<li>如果初始值列表中的元素个数少于类的元素成员数量，则靠后的成员被值初始化。</li>
</ul>
<p>显式初始化类的对象的成员存在三个明显的缺点：</p>
<ul>
<li>要求类的所有成员都是public的。</li>
<li>将正确的初始化每个对象的每个成员的重任交给了类的用户，而非类的作者。</li>
<li>添加或删除一个成员之后，所有的初始化语句都需要更新。</li>
</ul>
<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p><code>constexpr</code>函数的参数和返回值必须是字面值类型。字面值常量类和其他的类不同，字面值类型的类可能含有<code>constexpr</code>函数成员。这样的成员必须符合constexpr函数所有的要求，他们是隐式的<code>const</code>的。</p>
<p>数据成员都是字面值类型的聚合类是字面值产量类。如果一个类不是聚合类，但它符合下述要求，则它也是一个字面常量类：</p>
<ul>
<li>数据成员都必须是字面值类型。</li>
<li>类必须至少含有一个constexpr构造函数。</li>
<li>如果一个数据成员还有类内初始化，则内置的类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。</li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。<h4 id="constexpr构造函数"><a href="#constexpr构造函数" class="headerlink" title="constexpr构造函数"></a>constexpr构造函数</h4><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2>有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。</li>
</ul>
<h4 id="申明静态成员"><a href="#申明静态成员" class="headerlink" title="申明静态成员"></a>申明静态成员</h4><p>我们通过在成员的申明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是<code>public</code>的或<code>private</code>的。静态数据成员的类型可以是常量、引用、指针、类类型等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amout += amout * interestRate; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> owner;</span><br><span class="line">        <span class="keyword">double</span> amount;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。因此每个Account对象将包含两个数据成员：owner和amout。只存在一个<code>interestRate</code>对象而且它被所有的Account对象共享。</p>
<p>静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明称const的，而且我们也不能在<code>static</code>函数体内使用<code>this</code>指针。这一限制既适用于<code>this</code>的显式使用，也对调用非静态成员的隐式使用有效。</p>
<p>理解：这里和<code>Objective-C</code>中的<code>[Class function]</code>函数类似。</p>
<h4 id="使用类的静态成员"><a href="#使用类的静态成员" class="headerlink" title="使用类的静态成员"></a>使用类的静态成员</h4><p>使用作用域</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r;</span><br><span class="line">r = Account::rate();</span><br></pre></td></tr></table></figure>
<p>静态成员不属于类的某个对象，但是我们任然可以使用类的对象、引用或者指针来访问静态成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line"><span class="comment">//调用静态成员函数rate的等价形式</span></span><br><span class="line">r = ac1.rate();    <span class="comment">//通过Account的对象或引用</span></span><br><span class="line">r = ac2-&gt;rate(); <span class="comment">//通过指向Account的对象的指针</span></span><br></pre></td></tr></table></figure>
<h4 id="定义静态成员"><a href="#定义静态成员" class="headerlink" title="定义静态成员"></a>定义静态成员</h4><p>可以在类的内部也可以在类的外部定义静态成员函数。但是在类的外部定义静态成员时，不能重复<code>static</code>关键字，该关键字只出现在类的内部声明语句中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Account::rate(<span class="keyword">double</span> newRate) &#123;</span><br><span class="line">    interestRate = newRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为静态数据成员不属于类的任何一个对象，所以也不是在类对象创建时候被定义的，也就不是用构造函数初始化的。而且一般来说，我们也不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。</p>
<p>类似于全局变量，静态数据成员定义在任何函数之外，因此一旦它被定义，就将一直存在程序的整个生命周期中。</p>
<p>我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Account::interestRate = initRate();</span><br></pre></td></tr></table></figure>
<h4 id="静态成员类内初始化"><a href="#静态成员类内初始化" class="headerlink" title="静态成员类内初始化"></a>静态成员类内初始化</h4><h4 id="静态成员能用于某些场景，而普通成员不能"><a href="#静态成员能用于某些场景，而普通成员不能" class="headerlink" title="静态成员能用于某些场景，而普通成员不能"></a>静态成员能用于某些场景，而普通成员不能</h4>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/21/C++/顺序容器/" rel="next" title="顺序容器">
                <i class="fa fa-chevron-left"></i> 顺序容器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/favicon.ico"
               alt="Huanrong" />
          <p class="site-author-name" itemprop="name">Huanrong</p>
           
              <p class="site-description motion-element" itemprop="description">不积跬步，无以至千里；不积小流，无以成江海。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义抽象数据类型"><span class="nav-number">1.</span> <span class="nav-text">定义抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计Sales-data类"><span class="nav-number">1.1.</span> <span class="nav-text">设计Sales_data类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用改进的Sales-data类"><span class="nav-number">1.1.1.</span> <span class="nav-text">使用改进的Sales_data类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义改进的Sales-data类"><span class="nav-number">1.2.</span> <span class="nav-text">定义改进的Sales_data类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义成员函数"><span class="nav-number">1.2.1.</span> <span class="nav-text">定义成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引入this"><span class="nav-number">1.2.2.</span> <span class="nav-text">引入this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引入const成员函数❓❓❓"><span class="nav-number">1.2.3.</span> <span class="nav-text">引入const成员函数❓❓❓</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类作用域和成员函数"><span class="nav-number">1.2.4.</span> <span class="nav-text">类作用域和成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在类的外部定义成员函数"><span class="nav-number">1.2.5.</span> <span class="nav-text">在类的外部定义成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义一个返回this对象的函数"><span class="nav-number">1.2.6.</span> <span class="nav-text">定义一个返回this对象的函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义类相关的成员函数"><span class="nav-number">1.3.</span> <span class="nav-text">定义类相关的成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义read和print函数"><span class="nav-number">1.3.1.</span> <span class="nav-text">定义read和print函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义add函数"><span class="nav-number">1.3.2.</span> <span class="nav-text">定义add函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">1.4.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#合成的默认构造函数"><span class="nav-number">1.4.1.</span> <span class="nav-text">合成的默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#某些类不能依赖于合成的默认构造函数"><span class="nav-number">1.4.2.</span> <span class="nav-text">某些类不能依赖于合成的默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义Sales-data的构造函数"><span class="nav-number">1.4.3.</span> <span class="nav-text">定义Sales_data的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#default的含义"><span class="nav-number">1.4.4.</span> <span class="nav-text">=default的含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数初始值列表"><span class="nav-number">1.4.5.</span> <span class="nav-text">构造函数初始值列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在类的外部定义构造函数"><span class="nav-number">1.4.6.</span> <span class="nav-text">在类的外部定义构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拷贝、赋值和析构"><span class="nav-number">1.5.</span> <span class="nav-text">拷贝、赋值和析构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#某些类不能依赖于合成的版本"><span class="nav-number">1.5.1.</span> <span class="nav-text">某些类不能依赖于合成的版本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问控与封装"><span class="nav-number">2.</span> <span class="nav-text">访问控与封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用class或struct关键字"><span class="nav-number">2.0.1.</span> <span class="nav-text">使用class或struct关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#友元"><span class="nav-number">2.1.</span> <span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#友元的声明"><span class="nav-number">2.1.1.</span> <span class="nav-text">友元的声明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的其他特性"><span class="nav-number">3.</span> <span class="nav-text">类的其他特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类成员再探"><span class="nav-number">3.1.</span> <span class="nav-text">类成员再探</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义一个类型成员"><span class="nav-number">3.1.1.</span> <span class="nav-text">定义一个类型成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Screen类的成员函数"><span class="nav-number">3.1.2.</span> <span class="nav-text">Screen类的成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#令成员作为内联函数"><span class="nav-number">3.1.3.</span> <span class="nav-text">令成员作为内联函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重载成员函数"><span class="nav-number">3.1.4.</span> <span class="nav-text">重载成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可变数据成员"><span class="nav-number">3.1.5.</span> <span class="nav-text">可变数据成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类数据成员的初始值"><span class="nav-number">3.1.6.</span> <span class="nav-text">类数据成员的初始值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回-this的成员函数"><span class="nav-number">3.2.</span> <span class="nav-text">返回*this的成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从const成员函数返回-this-❓"><span class="nav-number">3.2.1.</span> <span class="nav-text">从const成员函数返回*this ❓</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于const的重载-❓"><span class="nav-number">3.2.2.</span> <span class="nav-text">基于const的重载 ❓</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类类型"><span class="nav-number">3.3.</span> <span class="nav-text">类类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类的声明"><span class="nav-number">3.3.1.</span> <span class="nav-text">类的声明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#友元再探"><span class="nav-number">3.4.</span> <span class="nav-text">友元再探</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类之间的友元关系"><span class="nav-number">3.4.1.</span> <span class="nav-text">类之间的友元关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#令成员函数作为友元"><span class="nav-number">3.4.2.</span> <span class="nav-text">令成员函数作为友元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数重载和友元"><span class="nav-number">3.4.3.</span> <span class="nav-text">函数重载和友元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#友元声明和作用域"><span class="nav-number">3.4.4.</span> <span class="nav-text">友元声明和作用域</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的作用域"><span class="nav-number">4.</span> <span class="nav-text">类的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#作用域和定义在类外部的成员"><span class="nav-number">4.0.1.</span> <span class="nav-text">作用域和定义在类外部的成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#名字查找和类的作用域"><span class="nav-number">4.1.</span> <span class="nav-text">名字查找和类的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用于类成员声明的名字查找"><span class="nav-number">4.1.1.</span> <span class="nav-text">用于类成员声明的名字查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型名要特殊处理"><span class="nav-number">4.1.2.</span> <span class="nav-text">类型名要特殊处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成员定义中普通块作用域的名字查找"><span class="nav-number">4.1.3.</span> <span class="nav-text">成员定义中普通块作用域的名字查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类作用域之外，在外围的作用域中查找"><span class="nav-number">4.1.4.</span> <span class="nav-text">类作用域之外，在外围的作用域中查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在文件中名字的出现处对其进行解析"><span class="nav-number">4.1.5.</span> <span class="nav-text">在文件中名字的出现处对其进行解析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数再探"><span class="nav-number">5.</span> <span class="nav-text">构造函数再探</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数初始值列表-1"><span class="nav-number">5.1.</span> <span class="nav-text">构造函数初始值列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数的初始值有时必不可少"><span class="nav-number">5.1.1.</span> <span class="nav-text">构造函数的初始值有时必不可少</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成员初始化的顺序"><span class="nav-number">5.1.2.</span> <span class="nav-text">成员初始化的顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认实参和构造函数"><span class="nav-number">5.1.3.</span> <span class="nav-text">默认实参和构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#委托构造函数"><span class="nav-number">5.2.</span> <span class="nav-text">委托构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认构造函数的作用"><span class="nav-number">5.3.</span> <span class="nav-text">默认构造函数的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用默认构造函数"><span class="nav-number">5.3.1.</span> <span class="nav-text">使用默认构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隐式的类类型转换"><span class="nav-number">5.4.</span> <span class="nav-text">隐式的类类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#只允许一部类类型转换"><span class="nav-number">5.4.1.</span> <span class="nav-text">只允许一部类类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类类型转换不是总是有效"><span class="nav-number">5.4.2.</span> <span class="nav-text">类类型转换不是总是有效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抑制构造函数定义的隐式转换"><span class="nav-number">5.4.3.</span> <span class="nav-text">抑制构造函数定义的隐式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#explicit构造函数只能用于直接初始化"><span class="nav-number">5.4.4.</span> <span class="nav-text">explicit构造函数只能用于直接初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为转换显式地使用构造函数"><span class="nav-number">5.4.5.</span> <span class="nav-text">为转换显式地使用构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标准库中含有显式构造函数的类"><span class="nav-number">5.4.6.</span> <span class="nav-text">标准库中含有显式构造函数的类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚合类"><span class="nav-number">5.5.</span> <span class="nav-text">聚合类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字面值常量类"><span class="nav-number">5.6.</span> <span class="nav-text">字面值常量类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr构造函数"><span class="nav-number">5.6.1.</span> <span class="nav-text">constexpr构造函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的静态成员"><span class="nav-number">6.</span> <span class="nav-text">类的静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#申明静态成员"><span class="nav-number">6.0.1.</span> <span class="nav-text">申明静态成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用类的静态成员"><span class="nav-number">6.0.2.</span> <span class="nav-text">使用类的静态成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义静态成员"><span class="nav-number">6.0.3.</span> <span class="nav-text">定义静态成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态成员类内初始化"><span class="nav-number">6.0.4.</span> <span class="nav-text">静态成员类内初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态成员能用于某些场景，而普通成员不能"><span class="nav-number">6.0.5.</span> <span class="nav-text">静态成员能用于某些场景，而普通成员不能</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huanrong</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://caohr.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://caohr.com/2018/12/21/C++/类/';
          this.page.identifier = '2018/12/21/C++/类/';
          this.page.title = '类';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://caohr.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  








  





  

  

  

  

  

  


  
</body>
</html>
