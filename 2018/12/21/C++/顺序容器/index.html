<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="一个容器就是一些特定类型对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="顺序容器">
<meta property="og:url" content="http://caohr.com/2018/12/21/C++/顺序容器/index.html">
<meta property="og:site_name" content="Huanrong">
<meta property="og:description" content="一个容器就是一些特定类型对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://caohr.com/2018/12/21/C++/顺序容器/media/15433109419820/001.png">
<meta property="og:updated_time" content="2018-12-21T07:45:30.896Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="顺序容器">
<meta name="twitter:description" content="一个容器就是一些特定类型对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。">
<meta name="twitter:image" content="http://caohr.com/2018/12/21/C++/顺序容器/media/15433109419820/001.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://caohr.com/2018/12/21/C++/顺序容器/"/>





  <title>顺序容器 | Huanrong</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-61905451-1', 'auto');
  ga('send', 'pageview');
</script>











</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Huanrong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">iOSDev</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://caohr.com/2018/12/21/C++/顺序容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huanrong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.ico">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huanrong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">顺序容器</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-21T15:40:10+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/21/C++/顺序容器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/12/21/C++/顺序容器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>一个容器就是一些特定类型对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</p>
<a id="more"></a>
<h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><table>
<thead>
<tr>
<th>容器类型</th>
<th>原理</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢</td>
</tr>
<tr>
<td>string</td>
<td>与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快</td>
</tr>
<tr>
<td>list</td>
<td>双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快</td>
</tr>
<tr>
<td>deque</td>
<td>双端列队。支持快速随机访问。在头尾位置插入/删除速度很快</td>
</tr>
<tr>
<td>forward_list</td>
<td>单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快</td>
</tr>
<tr>
<td>array</td>
<td>固定大小数组。支持快速访问随机访问。不能添加或者删除元素</td>
</tr>
</tbody>
</table>
<p><code>string</code>和<code>vector</code>将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时。</p>
<p><code>list</code>和<code>forward_list</code>两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。作为代价，这两个容器不支持元素的随机访问。为了访问一个元素，我们只能遍历整个容器。</p>
<p><code>deque</code>支持快速随机访问。但是在中间添加或删除元素的代价很高。但是在两端添加或删除元素都是很快的。与<code>list</code>和<code>forward_list</code>添加元素的速度相当。</p>
<p><code>forward_list</code>和<code>array</code>：<code>array</code>是大小是固定的，所以没有添加删除的操作。<code>forward_list</code>的设计目标是达到与最好的手写单向链表数据结构相当的性能。因此，<code>forward_list</code>没有<code>size</code>操作。因为保存或计算其大小就会比手写链表多出额外的开销。</p>
<h2 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h2><h3 id="对容器可以保存的元素类型的限制"><a href="#对容器可以保存的元素类型的限制" class="headerlink" title="对容器可以保存的元素类型的限制"></a>对容器可以保存的元素类型的限制</h3><table>
<thead>
<tr>
<th>容器操作（适用于所有的容器）</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型别名</strong></td>
<td></td>
</tr>
<tr>
<td>iterator</td>
<td>此容器类型的迭代器类型</td>
</tr>
<tr>
<td>const_iterator</td>
<td>可以读取元素，但不能修改元素的迭代器类型</td>
</tr>
<tr>
<td>size_type</td>
<td>无符号整数类型，足够保存此容器类型最大可能容器的大小</td>
</tr>
<tr>
<td>difference_type</td>
<td>带符号整数类型，足够保存两个迭代器之间的距离</td>
</tr>
<tr>
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr>
<td>reference</td>
<td>元素的左值类型：与<code>value_type&amp;</code>含义相同</td>
</tr>
<tr>
<td>const_reference</td>
<td>元素的const左值类型（既，const value_type&amp;）</td>
</tr>
<tr>
<td><strong>构造函数</strong></td>
<td></td>
</tr>
<tr>
<td>C c;</td>
<td>默认构造函数，构造空容器</td>
</tr>
<tr>
<td>C c1(c2)</td>
<td>构造c2的拷贝c1</td>
</tr>
<tr>
<td>C c(b, e)</td>
<td>构造c，将迭代器b和e指定的范围内的元素拷贝到c（array不支持）</td>
</tr>
<tr>
<td>C c(a, b, c…)</td>
<td>初始列表化c</td>
</tr>
<tr>
<td><strong>赋值与swap</strong></td>
<td></td>
</tr>
<tr>
<td>c1 = c2</td>
<td>将c1中的元素替换为c2中的元素</td>
</tr>
<tr>
<td>c1 = {a, b, c…}</td>
<td>将c1中的元素替换为列表中的元素（不适用于array） 花括号写在右边和左右有本质的区别</td>
</tr>
<tr>
<td>a.swap(b)</td>
<td>交换a和b的元素</td>
</tr>
<tr>
<td>swap(a, b)</td>
<td>与a.swap(b)等价</td>
</tr>
<tr>
<td><strong>大小</strong></td>
<td></td>
</tr>
<tr>
<td>c.size()</td>
<td>c中元素的数目(不支持forward_list)</td>
</tr>
<tr>
<td>c.max_size()</td>
<td>c可保存的最大元素数目</td>
</tr>
<tr>
<td>c.empty()</td>
<td>若c中存储了元素，返回false，否则返回true</td>
</tr>
<tr>
<td>添加/删除元素(不适用于array)</td>
<td>在不同的容器中，这些操作的接口都不同</td>
</tr>
<tr>
<td>c.insert(args)</td>
<td>将args中的元素拷贝进c</td>
</tr>
<tr>
<td>c.emplace(inits)</td>
<td>适用inists构造c中的一个元素</td>
</tr>
<tr>
<td>c.erase(args)</td>
<td>删除args指定的元素</td>
</tr>
<tr>
<td>c.clear()</td>
<td>删除args指定的元素</td>
</tr>
<tr>
<td><strong>关系运算符</strong></td>
<td></td>
</tr>
<tr>
<td>==, !=</td>
<td>所有容器都支持相等(不等)运算符</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>关系运算符（无序关联容器不支持）</td>
</tr>
<tr>
<td><strong>获取迭代器</strong></td>
<td></td>
</tr>
<tr>
<td>c.begin(), c.end()</td>
<td>返回指向c的首元素和尾元素之后位置的迭代器</td>
</tr>
<tr>
<td>c.cbegin(), c.cend()</td>
<td>返回const_iterator</td>
</tr>
<tr>
<td>反向容器的额外成员</td>
<td>不支持forward_list</td>
</tr>
<tr>
<td>reverse_iterator</td>
<td>按逆序寻址元素的迭代器</td>
</tr>
<tr>
<td>const_reverse_iterator</td>
<td>不能修改元素的逆序迭代器</td>
</tr>
<tr>
<td>c.rbegin(), c.rend()</td>
<td>返回指向c的尾元素和首元素之前位置的迭代器</td>
</tr>
<tr>
<td>c.crbegin(), c.crend()</td>
<td>返回const_reverse_iterator</td>
</tr>
</tbody>
</table>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。</p>
<p>迭代器支持的运算</p>
<ul>
<li>iter + n</li>
<li>iter - n</li>
<li>iter1 += n</li>
<li>iter1 -= n</li>
<li>iter1 - iter2</li>
<li><blockquote>
<p>, &gt;=, &lt;, &lt;=</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>forward_list迭代器不支持递减运算符<code>--</code>.<br>这些运算只能应用于string、vector、deque和array的迭代器。</p>
</blockquote>
<h4 id="迭代器范围"><a href="#迭代器范围" class="headerlink" title="迭代器范围"></a>迭代器范围</h4><p>一个迭代器范围（iterator range）由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者尾元素之后的位置。这两个迭代器通常被称为begin和end。</p>
<p>这种元素范围被称为左闭合区间（left-inclusive interval）数学描述为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[begin, end]</span><br></pre></td></tr></table></figure>
<h4 id="使用左闭合范围蕴含的编程假定"><a href="#使用左闭合范围蕴含的编程假定" class="headerlink" title="使用左闭合范围蕴含的编程假定"></a>使用左闭合范围蕴含的编程假定</h4><p>标准库使用左闭合范围是因为这种范围有三种方便的性质。</p>
<ul>
<li>如果begin和end相等，则范围为空</li>
<li>如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素</li>
<li>我们可以对begin递增若干次，使得begin==end</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (begin != end) &#123;</span><br><span class="line">    *begin = val;</span><br><span class="line">    ++begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3><p>每个容器都定义了多个类型。<code>size_type</code>、<code>iterator</code>和<code>const_iterator</code>。</p>
<p>类型别名：我们可以在不了解容器中元素类型的情况下使用它。<br>value_type: 元素类型<br>reference: 元素类型的一个引用<br>const_reference: 元素类型的一个不可修改的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iter是通过list&lt;string&gt;定义的一个迭代器类型</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line"><span class="comment">//count是通过vector&lt;int&gt;定义的一个difference_type类型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::difference_type count;</span><br></pre></td></tr></table></figure>
<h3 id="begin和end成员"><a href="#begin和end成员" class="headerlink" title="begin和end成员"></a>begin和end成员</h3><p><code>begin</code>和<code>end</code>操作生成指向容器中一个元素和尾元素之后位置的迭代器。这两个迭代器形成一个迭代器范围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; a = &#123;<span class="string">"Milton"</span>, <span class="string">"Shakespeare"</span>, <span class="string">"Austen"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.begin();       <span class="comment">//list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = a.rbegin();     <span class="comment">//list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.cbegin();     <span class="comment">//list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.crbegin();   <span class="comment">//list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure>
<p>当不需要写访问时，应使用<code>cbegin</code>和<code>cend</code></p>
<h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><p>每个容器类型都定义了一个默认构造器函数。除array之外，其他容器默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。</p>
<table>
<thead>
<tr>
<th>C c;</th>
<th>默认构造器。如果c是一个array，则c中元素按默认方式初始化；否则c为空</th>
</tr>
</thead>
<tbody>
<tr>
<td>C c1(c2) C c1=c2</td>
<td>C1初始化为C2的拷贝。c1和c2必须是相同类型（即，他们必须是相同的容器类型，且保存的是相同的元素类型；对于array类型，两者还必须具有相同大小）</td>
</tr>
<tr>
<td>C c{a, b,c…} C c={a, b, c…}</td>
<td>c初始化为初始化列表中元素的拷贝。列表中元素的类型必须与C的元素类型相容。对于array类型，列表中元素数目必须等于或小于array的大小，任何遗漏的元素都进行值的初始化。</td>
</tr>
<tr>
<td>C c(b, e)</td>
<td>c初始化为迭代器b和e指定范围中的元素的拷贝。array不使用</td>
</tr>
<tr>
<td>只有顺序容器</td>
<td></td>
</tr>
<tr>
<td>C seq(n)</td>
<td>seq包含n个元素，这些元素进行了值初始化：此构造函数是explicit的，string不适用</td>
</tr>
<tr>
<td>C seq(n, t)</td>
<td>seq包含n个初始化为值t的元素</td>
</tr>
</tbody>
</table>
<h4 id="将一个容器初始化为另一个容器的拷贝"><a href="#将一个容器初始化为另一个容器的拷贝" class="headerlink" title="将一个容器初始化为另一个容器的拷贝"></a>将一个容器初始化为另一个容器的拷贝</h4><p>将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器，或者（array除外）拷贝由一个迭代器对指定的元素范围。</p>
<p>创建一个容器是另外一个容器的拷贝容器的类型必须匹配。但是当用迭代器来指定范围拷贝，就不需要容器类型为相同的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; authors = &#123;<span class="string">"Milton"</span>, <span class="string">"Shakespeare"</span>, <span class="string">"Austen"</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; articles = &#123;<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; list2(authors);    <span class="comment">//正确：类型匹配</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; authList(authors) <span class="comment">//错误：容器类型不匹配</span></span><br><span class="line">forward_list&lt;<span class="built_in">string</span>&gt;  words(articles.begin(), articles.end());</span><br></pre></td></tr></table></figure>
<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; authors = &#123;<span class="string">"Milton"</span>, <span class="string">"Shakespeare"</span>, <span class="string">"Austen"</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; articles = &#123;<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>显式的指定了容器中每个元素的值。对于除array之外的容器类型，初始化列表还隐含的指定了容器的大小：容器将包含于初始值一样多的元素。</p>
<h4 id="与顺序容器大小相关的构造函数"><a href="#与顺序容器大小相关的构造函数" class="headerlink" title="与顺序容器大小相关的构造函数"></a>与顺序容器大小相关的构造函数</h4><p>除array外，提供另外一个构造函数，它接受一个容器大小和一个元素初始值。如果不提供元素初始值，则标准库会创建一个值初始化器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>, <span class="number">-1</span>);      <span class="comment">//10个int元素，每个都初始化为-1</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>, <span class="string">"hi!"</span>);  <span class="comment">//10个strings，每个都初始化为"hi!"</span></span><br><span class="line">forward_list&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>);  <span class="comment">//10个元素，每个都初始化为0</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>);       <span class="comment">//10个元素，每个都是空string</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>容器中的元素如果有默认的初始值则值需要提供容器大小参数，如果没有默认的构造函数，则除了大小参数外，还必须指定一个显式的元素初始值。<br>关联容器不支持大小值。</p>
</blockquote>
<h4 id="标准库array具有固定大小"><a href="#标准库array具有固定大小" class="headerlink" title="标准库array具有固定大小"></a>标准库array具有固定大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 42&gt;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="built_in">string</span>, 10&gt;</span><br></pre></td></tr></table></figure>
<p>为了使用array类型，我们必须同时指定元素类型和带下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt;::size_type i;    <span class="comment">//数组类型包括元素类型和大小</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>&gt;::size_type j;           <span class="comment">//错误：array&lt;int&gt;不是一个类型</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>大小也是array类型的一部分。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia1;           <span class="comment">//10个默认初始化的int</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 7&gt; ia2 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;  <span class="comment">//列表初始化</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; isa3 = &#123;<span class="number">42</span>&#125;;    <span class="comment">//第一个元素为42，其他的都为0.</span></span><br></pre></td></tr></table></figure>
<p>内置数组的拷贝，这个其实就是c语言中的数组，不能直接通过赋值考拷贝，需要借助函数，c语言类型的字符串也是这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> digs[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cpy[<span class="number">10</span>] = digs;        <span class="comment">//内置数组不支持拷贝或赋值</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; digits = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; copy = digits;</span><br></pre></td></tr></table></figure>
<p>直接用=号赋值，除了和上面一样要求容器类型要一致，array还额外要求大小也要一致，因为大小也是array类型中的一部分。</p>
<h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h3><p>赋值运算是将其左边容器中的全部元素替换为右边容器中元素的拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = c2;</span><br><span class="line">c1 = &#123;a, b, c&#125;;</span><br></pre></td></tr></table></figure>
<p>第一个赋值运算后，左边容器将于右边容器相等。如果两个容器原来大小不同，赋值运算后两者的大小都与右边容器的原大小相同。第二个赋值运算后，c1的size变为3，即花括号列表中值的数目。❓❓这两个赋值的区别是什么没有明白，不都是一样的吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; a1 = &#123;<span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span> ,<span class="number">3</span> ,<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; a2 = &#123;<span class="number">0</span>&#125;;   <span class="comment">//所有元素值均为0；</span></span><br><span class="line">a1 = a2;</span><br><span class="line">a2 = &#123;<span class="number">1</span>&#125;;    <span class="comment">//错误：不能讲一个花括号列表赋予数组  ❓❓【应该是因为只有一个元素，如果大小相等就没有关系。】</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于上面<code>a2={1}</code>的相关讨论，在<code>Xcode</code>里面允许这种类型的赋值，但是结果是把后面的元素填充为0。达到和array定义的大小相同。所以<code>a2</code>的最终值是<code>{1, 0, 0, 0, 0, 0, 0, 0, 0, 0}</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>容器复制运算</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>c1 = c2</td>
<td>c1和c2必须拥有相同的类型。</td>
</tr>
<tr>
<td>c = {a, b, c…}</td>
<td>将c1中元素替换为初始化列表中元素的拷贝(array不适用❓)</td>
</tr>
<tr>
<td>swap(c1, c2)/c1.swap(c2)</td>
<td>交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多。</td>
</tr>
<tr>
<td>assign操作不适用于关联容器和array</td>
<td></td>
</tr>
<tr>
<td>seq.assign(b,e)</td>
<td>将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素</td>
</tr>
<tr>
<td>seq.assign(il)</td>
<td>将seq中的元素替换为初始化列表il中的元素</td>
</tr>
<tr>
<td>seq.assign(n, t)</td>
<td>将seq中的元素替换为n个值为t的元素</td>
</tr>
</tbody>
</table>
<p>赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效（容器类型为array和string的情况除外）。</p>
<h4 id="使用assign-仅顺序容器"><a href="#使用assign-仅顺序容器" class="headerlink" title="使用assign(仅顺序容器)"></a>使用assign(仅顺序容器)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; oldstyle;</span><br><span class="line">names = oldstyle;    <span class="comment">//错误：容器类型不匹配</span></span><br><span class="line"><span class="comment">//正确：可以将const char*转换为string</span></span><br><span class="line">name.assign(oldstyle.cbegin(), oldstyle.cend());</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist1(<span class="number">1</span>);         <span class="comment">//1个元素，为空string</span></span><br><span class="line">slist1.assign(<span class="number">10</span>, <span class="string">"Hiya!"</span>);   <span class="comment">//10个元素，每个都是`Hiya!`</span></span><br></pre></td></tr></table></figure>
<h4 id="使用swap"><a href="#使用swap" class="headerlink" title="使用swap"></a>使用swap</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec1(<span class="number">10</span>);   <span class="comment">//10个元素的vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec2(<span class="number">24</span>);   <span class="comment">//24个元素的vector</span></span><br><span class="line">swap(svec1, svce2);</span><br></pre></td></tr></table></figure>
<p>元素本身并未交换，swap只是交换了两个容器的内部数据结构。</p>
<p>元素不会被移动，意味着之前指向这些元素的迭代器，引用和指针在swap操作之后都不会失效。但是元素已经属于不同的容器了。但是对于string的调用<code>swap</code>会导致迭代器、引用和指针失效。</p>
<h3 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h3><p>每个类型都有三个与大小相关的操作。<br>size/empty/max_size.</p>
<blockquote>
<p>forward_list支持max_size和empty，但不支持size。</p>
</blockquote>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>每个容器类型都支持<code>==</code>和<code>!=</code>.除了无序关联容器外的所有容器都支持关系运算符(&gt;、&gt;=、&lt;、&lt;=)。相比较的对象必须是相同类型的容器。</p>
<ul>
<li>如果两个容器具有相同大小且所有的元素都两两对应相等，则这两个容器相等：否则两个容器不等。</li>
<li>如果两个容器大小不同，但较小容器中每个元素都等于较大容器中对应元素，则较小容器小于较大容器。</li>
<li>如果两个容器都不是另一个容器【前缀子序列】，则他们的比较结果取决于第一个不相等的元素的比较结果。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>&#125;;</span><br><span class="line">v1 &lt; v2 <span class="comment">//true</span></span><br><span class="line">v1 &lt; v3 <span class="comment">//false</span></span><br><span class="line">v1 == v4</span><br><span class="line">v1 == v2</span><br></pre></td></tr></table></figure>
<h4 id="容器的关系运算符使用元素的关系运算符完成比较"><a href="#容器的关系运算符使用元素的关系运算符完成比较" class="headerlink" title="容器的关系运算符使用元素的关系运算符完成比较"></a>容器的关系运算符使用元素的关系运算符完成比较</h4><p>只有当元素也定义了相应的比较运算符，我们才可以使用关系运算符来比较两个容器。<br>相等运算符实际上是使用元素的<code>==</code>运算符实现比较的，而其他关系运算符是使用元素的&lt;运算符。</p>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><p>顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到元素如何存储、访问、添加以及删除。</p>
<h3 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h3><p>除了<code>array</code>外，所有的标准库容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器的大小。</p>
<table>
<thead>
<tr>
<th>c.push_back(t) c.emplace_back(args)</th>
<th>在c的尾添加元素t或args，返回void</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.push_front(t) c.emplace_front(args)</td>
<td>在c的头部创建一个值为t或args，返回void</td>
</tr>
<tr>
<td>c.insert(p,t) c.emplace(p..args)</td>
<td>在迭代器p指向的元素之前创建一个值为t或由args创建的元素。返回指向新添加的元素的迭代器。</td>
</tr>
<tr>
<td>c.insert(p,n,t)</td>
<td>在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器：若n为0，则返回p</td>
</tr>
<tr>
<td>c.insert(p,b,e)</td>
<td>在迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回p</td>
</tr>
<tr>
<td>c.insert(p,il)</td>
<td>il是一个花括号包围的元素列表。将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回p</td>
</tr>
</tbody>
</table>
<p><code>forward_list</code>有自己专门的<code>insert</code>和<code>emplace</code>;<br><code>forward_list</code>不支持<code>push_back</code>和<code>emplace_back</code><br><code>vector</code>和<code>string</code>不支持<code>push_front</code>和<code>emplace_front</code></p>
<p>但我们使用这些操作的时候，必须记得不同的容器使用不同的策略来分配元素空间，而这些策略直接影响了性能。在<code>vector</code>和<code>string</code>的尾部之外的任何位置，或是一个<code>deque</code>的首尾之外的任何位置添加元素，都需要移动元素。而且向一个<code>vector</code>和<code>string</code>添加元素可能引起整个对象存储空间重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中。</p>
<h4 id="使用push-back"><a href="#使用push-back" class="headerlink" title="使用push_back"></a>使用push_back</h4><p>除了<code>array</code>和<code>forward_list</code>之外，每个顺序容器（包括string类型）都支持<code>push_back</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word) &#123;</span><br><span class="line">    container.push_back(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在container末尾添加一个元素，这个元素值为<code>word</code>的拷贝。<br>因为string是一个字符容器，所以我们也可以用<code>push_back</code>在末尾添加字符。</p>
<blockquote>
<p>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器的都是对象值的一个拷贝，并不是对象本身。插入后元素和提供只的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。</p>
</blockquote>
<h4 id="使用push-front"><a href="#使用push-front" class="headerlink" title="使用push_front"></a>使用push_front</h4><p>除了<code>push_back</code>、<code>list</code>、<code>forward_list</code>和deque容器还支持<code>push_front</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ilist.push_front(ix);</span><br></pre></td></tr></table></figure>
<p><code>deque</code>和<code>vector</code>一样提供了随机访问元素的能力，但它提供了<code>vector</code>所不支持<code>push_front</code>。<code>deque</code>保存在容器首位插入和删除元素的操作都只花费常数时间。与<code>vector</code>一样，在<code>deque</code>尾部之外的位置插入会很耗时。</p>
<h4 id="在容器中的特定位置添加元素"><a href="#在容器中的特定位置添加元素" class="headerlink" title="在容器中的特定位置添加元素"></a>在容器中的特定位置添加元素</h4><p>vector、deque、list和string支持<code>insert</code>成员。<code>forward_list</code>提供了特殊版本的<code>insert</code>成员。对于<code>string</code>和<code>vector</code>不支持<code>push_front</code>我们可以使用<code>insert</code>来解决在首部位置插入的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist;</span><br><span class="line"><span class="comment">//等价于调用slist.push_front("Hello!");</span></span><br><span class="line">slist.insert(slist.begin(), <span class="string">"Hello!"</span>);</span><br><span class="line"><span class="comment">//插入到vector尾部之外的任何位置都可能很慢</span></span><br><span class="line">svec.insert(svec.begin(), <span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="插入范围内元素"><a href="#插入范围内元素" class="headerlink" title="插入范围内元素"></a>插入范围内元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svec.insert(svec.end(), <span class="number">10</span>, <span class="string">"Anna"</span>);</span><br></pre></td></tr></table></figure>
<p>代码将10个元素插入到<code>svec</code>的末尾，并将所有的元素都初始化为<code>string`</code>Anna`。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = &#123;<span class="string">"quasi"</span>, <span class="string">"simba"</span>, <span class="string">"frollo"</span>, <span class="string">"scar"</span>&#125;;</span><br><span class="line">slist.insert(slist.begin(), v.end()<span class="number">-2</span>, v.end());</span><br><span class="line">slist.insert(slist.end(), &#123;<span class="string">"these"</span>, <span class="string">"words"</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="使用insert的返回值"><a href="#使用insert的返回值" class="headerlink" title="使用insert的返回值"></a>使用insert的返回值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; lst;</span><br><span class="line"><span class="keyword">auto</span> iter = lst.begin();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word) &#123;</span><br><span class="line">    iter = lst.insert(iter, word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insert的函数返回来的值指向插入的元素的位置。所以这个循环会一直把新的元素加到list的最前面。</p>
<h4 id="使用emplace操作"><a href="#使用emplace操作" class="headerlink" title="使用emplace操作"></a>使用emplace操作</h4><p><code>emplace_front`</code>emplace<code></code>emplace_back`</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在c的尾部构造一个Sales_data对象</span></span><br><span class="line"><span class="comment">//使用三个参数的Sales_data构造函数</span></span><br><span class="line">c.emplace_back(<span class="string">"978-0590353403"</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line">c.push_back(<span class="string">"978-0590353403"</span>, <span class="number">25</span>, <span class="number">15.99</span>); <span class="comment">//错误</span></span><br><span class="line">c.push_back(Sales_data(<span class="string">"978-0590353403"</span>, <span class="number">25</span>, <span class="number">15.99</span>));</span><br></pre></td></tr></table></figure>
<p><code>emplace_back</code>可以调用容器中的元素的构造函数创建一个新的对象并添加到末尾。而<code>push_back</code>只是拷贝已经容器中的元素。他们本质上都是创建了新的对象。在调用<code>emplace_back</code>时，会在容器管理的内存空间中直接创建对象。而调用<code>push_back</code>则会创建一个局部临时对象，并将其压入容器中。</p>
<p>emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>包括<code>array</code>在内的每一个顺序容器都有一个front成员函数，而除<code>forward_list</code>之外的所有顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vale和val2是c中第一个元素的拷贝</span></span><br><span class="line"><span class="keyword">auto</span> val = *c.begin(), val2 = c.front();</span><br><span class="line"><span class="comment">// vale3和val4是c中最后一个元素值的拷贝</span></span><br><span class="line"><span class="keyword">auto</span> last = c.end();</span><br><span class="line"><span class="keyword">auto</span> val3 = *(--last);     <span class="comment">//不能递减forward_list迭代器</span></span><br><span class="line"><span class="keyword">auto</span> val4 = c.back();    <span class="comment">//forward_list不支持</span></span><br></pre></td></tr></table></figure>
<p><code>*c.begin()</code>返回的是指针所以需要在前面加<code>*</code>解引用。<br>因为<code>c.end()</code>返回的是元素末尾的一个不存在地址。所以需要递减来获得最后的元素。</p>
<table>
<thead>
<tr>
<th>在顺序容器中访问元素的操作</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td>c.back()</td>
<td style="text-align:center">返回c中尾元素的引用。若c为空，函数行为未定义</td>
</tr>
<tr>
<td>c.front()</td>
<td style="text-align:center">返回c中首元素的引用。若c为空，函数行为未定义</td>
</tr>
<tr>
<td>c[n]</td>
<td style="text-align:center">返回c中下标为n的元素的引用，n是一个无符号整数。若n&gt;=c.size(),则函数行为未定义</td>
</tr>
<tr>
<td>c.at(n)</td>
<td style="text-align:center">返回下标为n的元素的引用。如果下标越界，则抛出out_of_range异常</td>
</tr>
</tbody>
</table>
<p><code>at</code>和下标操作只适用于string、vector、deque和array。<br><code>back</code>不适用于<code>forward_list</code>。</p>
<h4 id="访问成员函数返回的是引用"><a href="#访问成员函数返回的是引用" class="headerlink" title="访问成员函数返回的是引用"></a>访问成员函数返回的是引用</h4><p>在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是<code>const</code>对象，则返回值是<code>const</code>的引用。如果容器不是<code>const</code>的，则返回值是普通引用，我们可以用来改变元素的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!c.empty()) &#123;</span><br><span class="line">    c.front() = <span class="number">42</span>;    <span class="comment">//将42赋予c中的第一个元素</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;v = c.back();    <span class="comment">//获得指向最后一个元素的引用</span></span><br><span class="line">    v = <span class="number">1024</span>;     <span class="comment">// 改变c中的元素</span></span><br><span class="line">    <span class="keyword">auto</span> v2  = c.back;    <span class="comment">//v2不是一个引用，它是c.back()的一个拷贝</span></span><br><span class="line">    v2 = <span class="number">0</span>;       <span class="comment">//未改变c的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<code>auto &amp;v = c.back();</code>不写&amp;符号，那么获得的直接是最后一个元素的拷贝值，不是引用。</p>
<h4 id="下标操作和安全的随机访问"><a href="#下标操作和安全的随机访问" class="headerlink" title="下标操作和安全的随机访问"></a>下标操作和安全的随机访问</h4><p>提供快速随机访问的容器(string, vector, deque和array)也都提供下标运算符。下标运算符接受一个下标参数，返回容器中该位置的元素的引用。下标在范围内是程序员的责任。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;    <span class="comment">//空vector</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec[<span class="number">0</span>];          <span class="comment">//运行时错误：svec中没有元素！</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.at(<span class="number">0</span>);      <span class="comment">//抛出一个out_of_range异常。</span></span><br></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><table>
<thead>
<tr>
<th>c.pop_back()</th>
<th>删除c中尾元素。若c为空，则函数行为未定义。函数返回void。</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.pop_front()</td>
<td>删除c中首元素。若c为空，则函数行为未定义。函数返回void。</td>
</tr>
<tr>
<td>c.erase(p)</td>
<td>删除迭代器p所指定的元素，返回一个指想被删除元素之后元素的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器，则函数行为未定义。</td>
</tr>
<tr>
<td>C.erase(b,e)</td>
<td>删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删除元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器。</td>
</tr>
<tr>
<td>C.clear()</td>
<td>删除c中所有的元素。返回void</td>
</tr>
</tbody>
</table>
<p>这些操作会改变容器的大小，所以不适用于<code>array</code>。<br><code>forward_list</code>有特俗版本的erase。<br><code>forward_list</code>不支持<code>pop_back</code>; <code>vector</code>和<code>string</code>不支持<code>pop_front</code>。<br>返回值都是<code>void</code>，所以在弹出之前就要保存好等待被删除的元素。</p>
<h4 id="pop-front和pop-back成员函数"><a href="#pop-front和pop-back成员函数" class="headerlink" title="pop_front和pop_back成员函数"></a>pop_front和pop_back成员函数</h4><p><code>pop_front</code>和<code>pop_back</code>成员函数分别删除首元素和尾元素。与<code>vecttor</code>和<code>string</code>不支持<code>push_front</code>一样。这些类型也不支持<code>pop_front</code>.类似的<code>forward_list</code>不支持<code>pop_back</code>。与元素访问成员函数类似，不能对一个空容器执行弹出操作。</p>
<h4 id="从容器内部删除一个元素"><a href="#从容器内部删除一个元素" class="headerlink" title="从容器内部删除一个元素"></a>从容器内部删除一个元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="number">1</span>st = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="number">1</span>st.begin();</span><br><span class="line"><span class="keyword">while</span> (it != lst.end()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it % <span class="number">2</span>) &#123;</span><br><span class="line">        it = <span class="number">1</span>st.erase(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除多个元素"><a href="#删除多个元素" class="headerlink" title="删除多个元素"></a>删除多个元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除两个迭代器表示的范围内的元素</span></span><br><span class="line"><span class="comment">//返回指向最后一个被删元素之后位置的迭代器</span></span><br><span class="line">elem1 = slist.erase(elem1, elem2);</span><br></pre></td></tr></table></figure>
<h3 id="特殊的forward-list操作"><a href="#特殊的forward-list操作" class="headerlink" title="特殊的forward_list操作"></a>特殊的forward_list操作</h3><p><code>forward_list</code>是一个单项链表，删除<code>elem3</code>会影响<code>elem2</code>。<br><img src="media/15433109419820/001.png" alt="001"></p>
<table>
<thead>
<tr>
<th>在forward_list中插入或删除元素的操作</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>lst.before_begin() / 1st.cbefore_begin()</td>
<td>返回指向链表首元素之前不存在元素的迭代器。<strong>此迭代器不能解引用</strong>。cbefore_begin()返回一个const_iterator</td>
</tr>
<tr>
<td>1st.insert_after(p, t) / 1st.insert_after(p,n,t)  / 1st.insert_after(p, b, e) / 1st.insert_after(p, il) /</td>
<td>在迭代器p之后的位置插入元素。t是一个对象，n是数量，b和e是表示范围的一堆迭代器（b和e不能只想1st内），il是一个花括号列表。返回一个指向最后一个插入元素的迭代器。如果范围为空，则返回p。若p为尾后迭代器，则函数行为未定义</td>
</tr>
<tr>
<td>emplace_after(p, args)</td>
<td>使用args在p指向的位置之后创建一个元素。返回一个指向这个新元素的迭代器。<strong>若p为尾后迭代器，则函数行为未定义。</strong></td>
</tr>
<tr>
<td>1st.erase_after(p)/1st.erase_after(b,e)</td>
<td>删除p指向的位置之后的元素，或删除从b之后直到（但不包含）e之间的元素，则返回尾后迭代器。如果p指向1st的尾元素或者是一个尾后迭代器，则函数行为未定义</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">forward_list&lt;<span class="keyword">int</span>&gt; f1st = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span> ,<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> prev = f1st.before_begin();</span><br><span class="line"><span class="keyword">auto</span> curr = f1st.begin();</span><br><span class="line"><span class="keyword">while</span> (curr != flst.end()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*curr %<span class="number">2</span>) &#123;</span><br><span class="line">        curr = flst.erase_after(prev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        ++curr;     <span class="comment">//curr之前的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p>如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会讲新元素添加到容器后部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist(<span class="number">10</span>, <span class="number">42</span>);      <span class="comment">//10个int，每个值都是42</span></span><br><span class="line">ilist.resize(<span class="number">15</span>);                 <span class="comment">//将5个值为0的元素添加到ilist的末尾</span></span><br><span class="line">ilist.resize(<span class="number">25</span>, <span class="number">-1</span>);           <span class="comment">//将10个值为-1的元素添加到ilist的末尾</span></span><br><span class="line">ilist.resize(<span class="number">5</span>);                   <span class="comment">//从ilist末尾删除20个元素</span></span><br></pre></td></tr></table></figure>
<h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><p>向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。<br>在向容器添加元素后：</p>
<ul>
<li>如果容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。【未被重新分配具体是：容器缩小，应该都不会导致重新分配，但是容器增大则有可能。】</li>
<li>对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用会失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</li>
<li>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍然有效。<br>当容器中的元素被删除以后，指向该元素的迭代器、指针和引用都会失效，当我们删除一个元素后：</li>
<li>对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器（包括为后迭代器和首前迭代器），引用和指针仍然有效。</li>
<li>对于<code>deque</code>，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他的元素的迭代器、引用或指针也会失效。如果是删除<code>deque</code>的尾元素，则尾后迭代器也会失效，但其他迭代器，引用和指针不受影响；如果是删除首元素，这些也不会收影响。</li>
<li>对于<code>vector</code>和<code>string</code>，指向被删除元素之前元素的迭代器、引用和指针任然有效。</li>
</ul>
<blockquote>
<p>当我们删除元素的时候，尾后的迭代器总是会失效。</p>
</blockquote>
<h4 id="编写改变容器的循环程序"><a href="#编写改变容器的循环程序" class="headerlink" title="编写改变容器的循环程序"></a>编写改变容器的循环程序</h4><p>添加/删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步中都更新迭代器、引用或指针。如果循环中调用的是insert或erase，那么更新迭代器很容器。这些操作都是返回迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = vi.begin()</span><br><span class="line"><span class="keyword">while</span> (iter != vi.end()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*iter%<span class="number">2</span>) &#123;</span><br><span class="line">        iter = vi.insert(iter, *iter);</span><br><span class="line">        iter += <span class="number">2</span>；<span class="comment">// 向前移动迭代器，跳过当前元素以及插入到它之前的元素</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        iter = vi.erase(iter);    <span class="comment">//不应向前移动迭代器，iter指向我们删除的元素之后的元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不要保存end返回的迭代器"><a href="#不要保存end返回的迭代器" class="headerlink" title="不要保存end返回的迭代器"></a>不要保存end返回的迭代器</h4><p>当我们添加/删除vector或string的元素后，或在<code>deque</code>中首之外任何位置添加/删除元素后，原来end返回迭代器总是会失效。所以不要保存end返回的迭代器，而是每次调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> begin = v.begin(), end = v.end();</span><br><span class="line"><span class="keyword">while</span> (begin != end) &#123;</span><br><span class="line">    ++begin;</span><br><span class="line">    begin = v.insert(begin, <span class="number">42</span>);</span><br><span class="line">    ++begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为修改容器以后，<code>end()</code>容器就失效了，会导致死循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (begin != vi.end()) &#123;</span><br><span class="line">        ++begin;</span><br><span class="line">        begin = vi.insert(begin, <span class="number">42</span>);</span><br><span class="line">        ++begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>while</code>循环里面每次都调用<code>end()</code>可以避免失效的问题。</p>
<h2 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h2><p>因为<code>vector</code>存储是在连续的空间，所以添加新的元素可能会导致整个<code>vector</code>需要重新分配空间，并释放旧的空间。为了避免这种代价，标准库会分配比需求更大的内存空间来保存<code>vector</code>。<br>这种策略比每次都要重新分配空间的策略要高效得多。此策略其扩张操作通常比<code>list</code>和<code>deque</code>还要快。</p>
<h4 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h4><p><code>vector</code>和<code>string</code>提供了一些成员函数。<br><code>capacity</code>: 告诉容器在不扩展内存空间的情况下可以容纳多少个元素。<br><code>reserve</code>: 允许我们通知容器它应该准备保存多少个元素。</p>
<table>
<thead>
<tr>
<th>容器大小管理操作</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>c.shrink_to_fit()</td>
<td>请将capacity()减少为与size()相同大小</td>
</tr>
<tr>
<td>c.capacity()</td>
<td>不重新分配内存空间的话，c可以保存多少元素</td>
</tr>
<tr>
<td>c.reserve(n)</td>
<td>分配至少能容纳n个元素的内存空间</td>
</tr>
</tbody>
</table>
<p><code>shrink_to_fit</code>只适用于<code>vector</code>、<code>string</code>和<code>deque</code>。<br><code>capacity</code>和<code>reserve</code>只适用于<code>vector</code>和<code>string</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity : "</span> &lt;&lt; vi.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">vi.reserve(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity : "</span> &lt;&lt; vi.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">vi.shrink_to_fit();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity : "</span> &lt;&lt; vi.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Capacity : <span class="number">7</span></span><br><span class="line">Capacity : <span class="number">20</span></span><br><span class="line">Capacity : <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>Xcode运行结果，并不会额外分配空间，不知道原因是什么❓❓</p>
<h4 id="capacity和size"><a href="#capacity和size" class="headerlink" title="capacity和size"></a>capacity和size</h4><p>capacity：是指容器还有多少富余的空间。<br>size：是容器实际用了多少空间。</p>
<h2 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h2><h3 id="构造string的其他办法"><a href="#构造string的其他办法" class="headerlink" title="构造string的其他办法"></a>构造string的其他办法</h3><p>除了字符串那章介绍的构造函数，string支持的额外的构造函数：</p>
<table>
<thead>
<tr>
<th>n、len2和pos2都是无符号值</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>string s(cp, n)</td>
<td>s是cp指向的数组中前n个字符的拷贝。此数组至少应该含有n个字符。</td>
</tr>
<tr>
<td>string s(s2, pos2)</td>
<td>s是string s2从下标pos2开始的字符拷贝。若pos2&gt;s2.size(),构造函数的行为未定义</td>
</tr>
<tr>
<td>string s(s2, pos2, len2)</td>
<td>s是string s2从下标pos2开始len2个字符的拷贝。若pos2&gt;s2.size(),构造函数的行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符。</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">"Hello World!!!"</span>;   <span class="comment">//以空字符结束的数组</span></span><br><span class="line"><span class="keyword">char</span> noNull[] = &#123;<span class="string">'H'</span>, <span class="string">'i'</span>&#125;;          <span class="comment">//不是空字符结束</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(cp)</span></span>;          <span class="comment">//拷贝cp中的字符串知道遇到空字符; s1 == "Hello World111";</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(noNull, <span class="number">2</span>)</span></span>;   <span class="comment">//从noNull拷贝两个字符；s2 == "Hi";</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(noNull)</span></span>;      <span class="comment">//未定义：noNull不是空字符串结束</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(cp + <span class="number">6</span>, <span class="number">5</span>)</span></span>;   <span class="comment">//从cp[6]开始拷贝5个字符；s4 == "World"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s5</span><span class="params">(s1, <span class="number">6</span>, <span class="number">5</span>)</span></span>;    <span class="comment">//从s1[6]开始拷贝6个字符；s5 == "World"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(s1, <span class="number">6</span>)</span></span>;       <span class="comment">//从s1[6]开始拷贝6个字符，直至s1w末尾；s6=="World!!!"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(s1, <span class="number">6</span>, <span class="number">20</span>)</span></span>;   <span class="comment">//正确，只拷贝到s1末尾，s7 == "World!!!"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s8</span><span class="params">(s1, <span class="number">16</span>)</span></span>;      <span class="comment">//抛出一个out_of_range异常</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为<code>char noNull[] = {&#39;H&#39;, &#39;i&#39;};</code>的末尾不包含<code>null</code>元素，拷贝到string中，如果是从中间任何位置一直拷贝到字符串末尾，可能会因为没有<code>null</code>无法知道到底哪里才是字符串的末尾。但是如果你指定了范围，则不需要在乎后面是不是以<code>null</code>结尾。</p>
</blockquote>
<h4 id="substr操作"><a href="#substr操作" class="headerlink" title="substr操作"></a>substr操作</h4><p><code>substr</code>操作返回一个<code>string</code>，它是原始<code>string</code>的一部分或全部的拷贝。可以传递给<code>substr</code>一个可选的开始位置和数值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s.substr(<span class="number">0</span>, <span class="number">5</span>);    <span class="comment">//s2 = hello</span></span><br><span class="line"><span class="built_in">string</span> s3 = s.substr(<span class="number">6</span>);        <span class="comment">//s3 = world</span></span><br><span class="line"><span class="built_in">string</span> s4 = s.substr(<span class="number">6</span>, <span class="number">11</span>);  <span class="comment">//s3 = word</span></span><br><span class="line"><span class="built_in">string</span> s5 = s.substr(<span class="number">12</span>)       <span class="comment">//抛出一个out_of_range异常</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>子字符串操作</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>s.substr(pos, n)</td>
<td>返回一个string，包含s中从pos开始的n个字符串的拷贝。post的默认值为0。n的默认值为s.size()-pos,即拷贝从pos开始的所有字符。</td>
</tr>
</tbody>
</table>
<h3 id="改变string的其他办法"><a href="#改变string的其他办法" class="headerlink" title="改变string的其他办法"></a>改变string的其他办法</h3><h4 id="append和replace函数"><a href="#append和replace函数" class="headerlink" title="append和replace函数"></a>append和replace函数</h4><h4 id="改变string的多种重载函数"><a href="#改变string的多种重载函数" class="headerlink" title="改变string的多种重载函数"></a>改变string的多种重载函数</h4><h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><h4 id="指定在哪里开始搜索"><a href="#指定在哪里开始搜索" class="headerlink" title="指定在哪里开始搜索"></a>指定在哪里开始搜索</h4><h4 id="逆向搜索"><a href="#逆向搜索" class="headerlink" title="逆向搜索"></a>逆向搜索</h4><h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><h4 id="定义一个适配器"><a href="#定义一个适配器" class="headerlink" title="定义一个适配器"></a>定义一个适配器</h4><h4 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h4><h4 id="列队适配器"><a href="#列队适配器" class="headerlink" title="列队适配器"></a>列队适配器</h4>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/21/C++/const_cast/" rel="next" title="const_cast">
                <i class="fa fa-chevron-left"></i> const_cast
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/21/C++/类/" rel="prev" title="类">
                类 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/favicon.ico"
               alt="Huanrong" />
          <p class="site-author-name" itemprop="name">Huanrong</p>
           
              <p class="site-description motion-element" itemprop="description">不积跬步，无以至千里；不积小流，无以成江海。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序容器概述"><span class="nav-number">1.</span> <span class="nav-text">顺序容器概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器库概览"><span class="nav-number">2.</span> <span class="nav-text">容器库概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对容器可以保存的元素类型的限制"><span class="nav-number">2.1.</span> <span class="nav-text">对容器可以保存的元素类型的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器"><span class="nav-number">2.2.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器范围"><span class="nav-number">2.2.1.</span> <span class="nav-text">迭代器范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用左闭合范围蕴含的编程假定"><span class="nav-number">2.2.2.</span> <span class="nav-text">使用左闭合范围蕴含的编程假定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器类型成员"><span class="nav-number">2.3.</span> <span class="nav-text">容器类型成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#begin和end成员"><span class="nav-number">2.4.</span> <span class="nav-text">begin和end成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器定义和初始化"><span class="nav-number">2.5.</span> <span class="nav-text">容器定义和初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将一个容器初始化为另一个容器的拷贝"><span class="nav-number">2.5.1.</span> <span class="nav-text">将一个容器初始化为另一个容器的拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列表初始化"><span class="nav-number">2.5.2.</span> <span class="nav-text">列表初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与顺序容器大小相关的构造函数"><span class="nav-number">2.5.3.</span> <span class="nav-text">与顺序容器大小相关的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标准库array具有固定大小"><span class="nav-number">2.5.4.</span> <span class="nav-text">标准库array具有固定大小</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#赋值和swap"><span class="nav-number">2.6.</span> <span class="nav-text">赋值和swap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用assign-仅顺序容器"><span class="nav-number">2.6.1.</span> <span class="nav-text">使用assign(仅顺序容器)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用swap"><span class="nav-number">2.6.2.</span> <span class="nav-text">使用swap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器大小操作"><span class="nav-number">2.7.</span> <span class="nav-text">容器大小操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系运算符"><span class="nav-number">2.8.</span> <span class="nav-text">关系运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#容器的关系运算符使用元素的关系运算符完成比较"><span class="nav-number">2.8.1.</span> <span class="nav-text">容器的关系运算符使用元素的关系运算符完成比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序容器操作"><span class="nav-number">3.</span> <span class="nav-text">顺序容器操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#向顺序容器添加元素"><span class="nav-number">3.1.</span> <span class="nav-text">向顺序容器添加元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用push-back"><span class="nav-number">3.1.1.</span> <span class="nav-text">使用push_back</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用push-front"><span class="nav-number">3.1.2.</span> <span class="nav-text">使用push_front</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在容器中的特定位置添加元素"><span class="nav-number">3.1.3.</span> <span class="nav-text">在容器中的特定位置添加元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入范围内元素"><span class="nav-number">3.1.4.</span> <span class="nav-text">插入范围内元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用insert的返回值"><span class="nav-number">3.1.5.</span> <span class="nav-text">使用insert的返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用emplace操作"><span class="nav-number">3.1.6.</span> <span class="nav-text">使用emplace操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问元素"><span class="nav-number">3.2.</span> <span class="nav-text">访问元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#访问成员函数返回的是引用"><span class="nav-number">3.2.1.</span> <span class="nav-text">访问成员函数返回的是引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#下标操作和安全的随机访问"><span class="nav-number">3.2.2.</span> <span class="nav-text">下标操作和安全的随机访问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除元素"><span class="nav-number">3.3.</span> <span class="nav-text">删除元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pop-front和pop-back成员函数"><span class="nav-number">3.3.1.</span> <span class="nav-text">pop_front和pop_back成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从容器内部删除一个元素"><span class="nav-number">3.3.2.</span> <span class="nav-text">从容器内部删除一个元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除多个元素"><span class="nav-number">3.3.3.</span> <span class="nav-text">删除多个元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊的forward-list操作"><span class="nav-number">3.4.</span> <span class="nav-text">特殊的forward_list操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改变容器大小"><span class="nav-number">3.5.</span> <span class="nav-text">改变容器大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器操作可能使迭代器失效"><span class="nav-number">3.6.</span> <span class="nav-text">容器操作可能使迭代器失效</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编写改变容器的循环程序"><span class="nav-number">3.6.1.</span> <span class="nav-text">编写改变容器的循环程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不要保存end返回的迭代器"><span class="nav-number">3.6.2.</span> <span class="nav-text">不要保存end返回的迭代器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector对象是如何增长的"><span class="nav-number">4.</span> <span class="nav-text">vector对象是如何增长的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#管理容量的成员函数"><span class="nav-number">4.0.1.</span> <span class="nav-text">管理容量的成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#capacity和size"><span class="nav-number">4.0.2.</span> <span class="nav-text">capacity和size</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#额外的string操作"><span class="nav-number">5.</span> <span class="nav-text">额外的string操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造string的其他办法"><span class="nav-number">5.1.</span> <span class="nav-text">构造string的其他办法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#substr操作"><span class="nav-number">5.1.1.</span> <span class="nav-text">substr操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改变string的其他办法"><span class="nav-number">5.2.</span> <span class="nav-text">改变string的其他办法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#append和replace函数"><span class="nav-number">5.2.1.</span> <span class="nav-text">append和replace函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#改变string的多种重载函数"><span class="nav-number">5.2.2.</span> <span class="nav-text">改变string的多种重载函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string搜索操作"><span class="nav-number">5.3.</span> <span class="nav-text">string搜索操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指定在哪里开始搜索"><span class="nav-number">5.3.1.</span> <span class="nav-text">指定在哪里开始搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逆向搜索"><span class="nav-number">5.3.2.</span> <span class="nav-text">逆向搜索</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#compare函数"><span class="nav-number">5.4.</span> <span class="nav-text">compare函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值转换"><span class="nav-number">5.5.</span> <span class="nav-text">数值转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器适配器"><span class="nav-number">6.</span> <span class="nav-text">容器适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义一个适配器"><span class="nav-number">6.0.1.</span> <span class="nav-text">定义一个适配器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈适配器"><span class="nav-number">6.0.2.</span> <span class="nav-text">栈适配器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列队适配器"><span class="nav-number">6.0.3.</span> <span class="nav-text">列队适配器</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huanrong</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://caohr.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://caohr.com/2018/12/21/C++/顺序容器/';
          this.page.identifier = '2018/12/21/C++/顺序容器/';
          this.page.title = '顺序容器';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://caohr.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  








  





  

  

  

  

  

  


  
</body>
</html>
